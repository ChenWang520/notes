<center><font color=red size=15>数据库系统工程师笔记</font></center>

# 考试简介

45分及格

###### 上午-单选

###### 下午-填空、简答

## 最新版与之前的区别

第1章 ~~删除了原码反码补码  多媒体基础知识~~

第5章 ~~删除了OSI 7层网络模型~~ 增加了网络安全知识（认证、数字签名、报文摘要、数字认证）

第10章 增加了 10.6软件开发方法新进展

第13章 完全新增的章节

第14章 增加了 14.5大数据与数据库 14.6NewSQL数据库



## 上午题分值

第1-5章基础知识 28分

 <font color=red >重点：第6、7、8、11、12章</font>

## 下午题分值

每题15分

数据流图

补充ER图

关系规范化

SQL

两段锁协议

数据库恢复（新题型）

# 第一章计算机系统知识

## 1.1计算机硬件基础知识


$$
CPU=\left\{
\begin{aligned}
运算器 \\
算数逻辑单元\\
累加寄存器\\
数据缓冲寄存器\\
状态条件寄存器
\end{aligned}
\right.
$$

#### CPU的组成

>##### 运算器

功能：

>>1.算术运算

>>2.逻辑运算（与或非）

组成：

>>1.算术逻辑单元（ALU）

>><font color=red >2.累加寄存器（AC）：ALU运算时存储数据用的</font>

>>3.数据缓冲寄存器（DR）：从内存中读的内容暂时存放的地方

>>4.状态条件寄存器（PSW）：溢出标志、为0标志、为负标志

>##### 控制器

功能：

组成：
>>1.指令寄存器（IR）：暂存一条指令
>><font color=red >2.程序计数器(PC)：存放下一条要执行的指令的***地址***</font>
>>3.指令译码器（ID）：对操作码进行解析（指令包括操作码和操作数/或操作数所在的地址）

#### 进制转换

按权展开法:例如二进制11.11分别为2的1次方0次方-1次方-2次方

八/十六进制转为二进制:八进制(0)每一位转成3位二进制;十六进制(H)每一位转成4位二进制

#### 存储器与总线

存储器不太重要

##### 总线的分类
1.数据总线(DB):传输数据  双向  宽度决定每次交换数据的位数
2.地址总线(AB):传输地址  单向  地址总线的宽度决定最大寻址能力
3.控制总线(CB):用来传输控制信号时序信号 每一条是单向的,但可以双向传输

## 1.2计算机体系结构分类
>按处理机数量分类
>>1.单处理系统
>>2.并行处理与多处理系统
>>3.分布式处理系统

>按并行程度分类
>>Fiynn分类
>>冯泽云分类
>>Handler分类

>复杂指令集CISC和精简指令集RISC
>>CISC:x86 指令集庞大
>>RISC:RAM 指令少

#### 流水线计数
流水线技术执行n条指令的时间:执行一条指令的时间+(n-1)\*流水线周期(子任务中最长的时间)
最大吞吐率:流水线周期的倒数(忽略了那一条指令的时间)
实际吞吐率:n/n条指令的时间

#### 存储系统
p4-p7 了解即可

##### 高速缓存Cache
比主存快5-10倍 利用程序局部性原理
主要作用:协调CPU的主存存取速度的差异

>地址映像
>
>>1.直接映像(主存区号-区内块号-块内地址)  块号对应,区的数量=主存大小/Cache大小,主存分区,区里的块和Cache块相同,
>>2.全相联映像(主存块号-块内地址)  任意放
>>3.组相联映像(主存区号-组号-块号-块内地址)  将直接映像的分区后,区内再分组,Cache中的组一一对应(直接映像),块号任意只要在同一组内即可(全相联)

>Cache性能分析
>>加权平均访问时间=命中率\*Cache存取时间+（1-命中率）\*主存访问时间
>>虚拟存储器是逻辑存储器
>>相联存储器是按内容访问的存储器

>编址的相关计算
>>1 byte(字节)=8 bit 内存按字节编址 因此8字节的内存地址占3位 2的3次方
>>例：直接映像（区号 块号 块内地址）主存容量1MB Cache容量16KB 块为512B 
>>区号=1MB/16KB=64=2`6 需要6位 
>>块号=16KB/512B=32=2`5 需要5位 
>>块内地址=512B=2`9 需要9位

#### 输入输出技术
##### 程序控制方式
>1.无条件传送：外设总是准备好的
>2.程序查询方式：CPU查询外设的状态
><font color=red >3.中断方式：外设准备好后，向CPU发送中断请求，CPU保存现场</font>
>以上三种都需要CPU的参与
><font color=red >4.DMA方式（直接内存存取方式Direct Memory Access）：主存和外设之间</font>
>5.通道方式和外围处理机方式：增加硬件进一步减少CPU对I/O操作的控制

## 1.3安全性、可靠性、系统性能
### 对称加密
加密和解密使用相同的密钥

适合对大量文件进行加密
>代表算法：
>1.DES：替换和移位
>2.3DES
>3.RC-5
>4.IDEA
>5.AES：排列和置换

### 非对称加密
加密密钥和解密密钥

不适合对大量文件加密。因为加密解密需要大量时间

>两个应用场景
>加密模型：公钥加密和私钥解密
>认证模型：私钥加密和公钥解密（密文不保密，用于认证加密人的身份）

代表算法：RSA（基于大素数分解的困难性）

### 信息摘要
Hash函数：输入不固定，返回固定长度字符串
广泛采用的Hash函数：MD2、MD4、**MD5**产生128位 **SHA-1**产生160位

>数字签名
>1.发送者：Hash函数对信息取摘要
>2.发送者：私钥对摘要和所使用的hash加密（对摘要签名）
>3.发送者：发送加密后的数据和信息
>4.接收者：同样使用Hash对信息取摘要
>5.接收者：使用发送者的公钥解密，判断两个hash是否相同
>用于判断发送者的身份，缺点：信息是公开的

>数字加密（数字信封）
>1.发送者：对称加密对信息加密
>2.发送者：用接收者的公钥对对称密钥加密
>3.发送者：发送加密后的信息和加密后的对称密钥
>4.接受者：用私钥解密对称密钥
>5.接受者：用对称密钥解密密文信息
>保证发送信息的保密性，缺点：不能确认发送人的身份

数字签名和数字加密的区别和联系
数字签名使用的是发送方的密钥对（1对多）只采用非对称
数字加密使用的是接收方的密钥对（多对1）采用了对称和非对称，非对称对对称加密

### 计算机系统的可靠性
可靠性：t时间内正常运行的概率

>串联系统可靠性：R1\*R2\*R3\*R4
>并联系统的可靠性：1-(1-R1)(1-R2)(1-R3)(1-R4) **并联得所有都失败**

## 1.4 逻辑运算
与:&& and
或:|| or
异或:相异为真,相同为假
非:!

# 2程序语言基础
1.编译程序和解释程序
2.程序语言的数据成分和控制成分
3.编译程序的过程
4.中缀,前缀和后缀表达式

### 2.1程序语言概述
#### 2.1.1 程序语言基本概念
1.低级语言和高级语言
低级语言:机器语言和汇编语言 
高级语言:

2.汇编,解释,编译
高级语言转化为低级语言

3.编译程序和解释程序
>解释程序(解释器):逐条翻译并立即执行
>编译程序(编译器):(编译阶段)将源程序翻译成目标程序(目标代码).(运行阶段):执行目标程序

4.编译和解释的区别
>编译方式下:机器上运行的是目标程序.源程序和编译器都不再参与
>解释方式下:解释器和源程序一直参与,控制权在解释器

5.编译和解释的比较
>编译比解释效率更高
>解释比编译更灵活
>解释可移植性更好 (JS要求可移植性用的解释方式)

#### 2.1.2 程序语言的基本成分
##### 数据成分
1.常量和变量;左值(存储单元)/右值(值或内容) 变量有左值和右值,右值可以改变;常量只有右值,右值不能变
2.全局变量和局部变量;按作用域范围
3.数据类型
>基本类型
>特殊类型 空
>用户定义类型 枚举
>构造类型 数组 结构 联合
>指针类型
>抽象数据类型 类

##### 控制成分
1.顺序结构
2.选择结构
3.循环结构：初始化 循环体 循环条件

#### 2.2.2 编译过程
源程序翻译成目标程序



![编译过程](http://image-wangchen.oss-cn-shanghai.aliyuncs.com/img/编译过程.png)

1.词法分析：对源程序逐个扫描，识别出一个个的单词
2.语法分析：在单词的基础上，判断单词连起来(表达式/语句)是否合法。输出语法树
3.语义分析：类型分析和检查
4.中间代码的生成：常见的有后缀式/三地址码（四元式）/树
5.代码优化：可以在中间代码的生成中进行，也可以在目标代码的生成中进行
6.目标代码的生成：最后一个阶段，和机器相关
7.符号表管理
8.出错处理：静态错误（语法错误语义错误）和动态错误（数组越界）

>中缀，前缀，后缀表达式
>中缀：a+b-c
>前缀：-+abc 
>后缀：abc+-(通过**栈**方便计算)
>>例子：中缀**(a+b)\*c-d**
>>按优先级加括号**((（a+b）\*c)-d)**
>>运算符放在括号前**-(\*(+（ab）c)d)**
>>去括号**-\*+abcd**
>>例子：后缀：即第二步运算符放在括号后

# 3数据结构与算法
## 3.1线性结构
### 3.1.1线性表

定义:n个元素的有限序列
##### 线性表的顺序存储
>(逻辑上相邻的元素,物理上也相邻)
>优点:可以随机存取表中元素,按序号查找方便
>缺点:插入和删除需要移动元素

#####  线性表的链式存储
单链表/循环链表/双向链表
>优点:插入和删除不需要移动元素
>缺点:只能按顺序访问,不能随机存取

### 3.1.2 栈和队列
栈:后进先出
>顺序栈:空间预先申请,会栈满bottom head top 
>链栈:头指针就是栈顶指针

队列:先进先出
>顺序队列:队尾进rear,队头出front 
>循环队列:空时-front=rear
>链队列:有头节点,队列为空即头指针和尾指针相同

### 3.1.3 串（取值范围受限的线性表）
字符串的基本元素:字符
串长:字符的个数
串相等:长度相等且内容相同
串比较:比ascii码
>顺序存储
>链式存储



## 3.2 数组与矩阵
## 3.3 树和二叉树、
#### 概念
存在空树
度：孩子的个数
层次：根为第一层
高度：最大层次为高数或深度
>二叉树：
>每层最多2^(i-1)个节点
>深度为k，最多有2^(k)-1
>叶子节点数n0，度为1树n1，度为2数n2。n0=n2+1(判断孩子的数量n0\*0+n1\*1+n2\*2+1=n0+n1+n2)

满二叉树即最多（深度为k，最多有2^(k)-1）
完全二叉树：少的是最后的，编号与满二叉树一致
>完全二叉树性质
>对于编号i：双亲为i/2向下取整，孩子若存在孩子为2i和2i+1
>深度：lon2(n)向下取整+1

#### 二叉树存储结构
1.顺序存储：无孩纸置空
2.链式存储

#### 二叉树遍历
先中后
中序：按网格从早到右

#### 最优二叉树（哈夫曼树）
一直取两个最小的
带权路径长度：乘以几条边

#### 二叉查找树
中序遍历从小到大

## 3.4 图
图G（Graph）由两个集合V（Vertex）和E（Edge）组成
有向图：每条边都是有方向的，也称弧，起点为弧尾
完全图：任意两个节点之间都有边。无向图共有n(n-1)/2条边
路径长度：经过了几条边
连通图:任意两个节点之间都有路径(就是没有孤的)
强连通图(针对有向图)：任意两个节点之间都有路径
网：边带权值的图
### 图的存储结构
1.邻接矩阵法--n和节点则有nxn矩阵 有边为1或权值（无向图矩阵对称）
2.邻接链表表示法--为每个顶点建立单链表（与每个顶点相连的）有向图有逆邻接表（流入的节点）



## 3.5 排序算法

直接插入排序：按序插入待排关键字，插入时依次查找位置，直接插入，后面的一次后移

冒泡排序：一次把相邻的两个比较，交换位置

简单选择排序：每次选择最小的，与第一个没有排序的交换位置

希尔排序：间隔n个为一组，组内插入排序，依次将n缩小到1

快速排序：首尾指针，依次与枢轴比较

堆排序：反复将待排序列建立成堆，取堆顶

归并排序：两两一组，再四四一组，依次类推



《忆排序》
选泡插
快归堆希统计基
恩方恩老恩一三
对恩加K恩乘K
泡插归稳

## 3.6 查找算法
#### 查找表及效率
静态查找表:只进行查询和检索操作
动态查找表:还要插入和删除
关键字:识别数据元素
查找:确定是否存在
平均查找长度(ASL):关键字和给定值进行比较的次数的平均值:

#### 顺序查找
逐个比较

#### 折半查找(二分查找)
要求有序
适用表不易变动,而又查找频繁

#### 树表查找
二叉查找树
B树(B-树):B+树内部节点不存,全在叶子节点,叶子节点相连
红黑树

#### 索引顺序查找(分块查找)
表分块,块间有序

#### 哈希查找
哈希函数的构造
>冲突的解决
>开放定址法:
>>1.线性探测再散列(向后挪到空的)
>>2.二次探测再散列(向后向前1 4 9 16)
>>3.随机探测再散列
>链地址法(k值那有一条链)找的时候方便

## 3.7 图算法
#### 生成树和最小生成树
生成树要求连通图

权值最小的树为最小生成树
求最小生成树:普利姆算法和克鲁斯卡尔算法
>普利姆算法
>以顶点为主,找顶点到其余节点最小的路径,找到后并入顶点集合
>
>克鲁斯卡尔算法
>以边为主。每次找最小的边，有回路的边不要，要把新节点加进来

#### 最短路径法
>迪杰斯特拉算法
>第一步，判断起点到相邻节点的路径长度，找到最小的，加入起点集合
>第二部，判断起点集合到相邻节点的路径长度。再找到最小的
>依次迭代

# 操作系统

进程间的同步与互斥/信号量机制(PV操作)/死锁 是关键

### 操作系统的基本概念
>操作系统的定义：
>能有效的组织和管理系统中的各种软硬件资源，合理的组织计算机系统的工作流程，控制程序的执行，并且向用户提供一个良好的工作环境和友好接口

>操作系统的2个作用
>1.通过资源管理提高计算机系统的效率
>2.改善人机界面向用户提供友好的工作环境

操作系统的四个特征：并发性，共享性，虚拟性和不确定性

操作系统的五大功能
>进程管理
>文件管理
>存储管理
>设备管理
>作业管理

## 进程
### 进程的基本概念
进程是程序的一次执行
进程通常由组成
>程序
>数据
>进程控制块(PCB)

进程是**资源分配和独立运行**的基本单位

进程的两个基本属性
>可拥有资源的独立单位
>可独立调度和分配的基本单位

### 进程的状态转换（近十年没考，了解）
>运行
>阻塞：等待某种资源
>就绪：获得了除处理机外的所有资源

### 进程间的同步和互斥
进程间的同步
>是指系统中一些需要相互合作，协同工作的进程，这样的互相联系称为进程的同步

进程间的互斥
>指系统中的多个进程因争用临界资源而互斥执行

临界资源
>指有些资源一次只能供一个进程使用。如打印机、共享变量。

### 采用信号量机制(PV原语)实现同步和互斥
1.公用信号量：实现互斥，初值为1或资源数目
2.私用信号量：实现同步，初值为0或其他

信号量S的物理意义：>0表示资源可用数；<0，绝对值表示阻塞队列中等待的进程数
PV操作是常用方法，PV是低级通信原语，执行期间不可分割，P表示申请一个资源，V表示释放一个资源；PV操作成对出现！

P操作
>S=S-1;若S>=0,进程继续；若S<0，进程阻塞

V操作
>S=S+1;若S>0,进程继续（阻塞队列为空）；若S<=0，从阻塞队列唤醒一个进程，加入就绪队列

生产者消费者问题
P1不断生产资源，P2不断消耗资源
缓冲区只能有一个资源

### 死锁
两个以上的进程都互相请求对方已经占有的资源
至少需要（k-1)\*n+1个资源才不会死锁

#### 银行家算法
先求剩下的资源分别是多少，再求每个进程还需要的资源是多少

## 线程
>拥有资源
>可独立调度和分配的基本单位
>
分为
>用户级线程：不依赖内核，不利用系统调用
>内核支持线程：利用系统调用


## 存储管理
### 页式存储
页面大小为4K，则页内地址为12位（按字节编址，按B编址。4KB=2\*12B）
先判断页号是否越界，得到块号拼接页内地址。
### 段式存储
首先判断段号和段内地址是否越界，再根据基址加上段内地址
### 段页式存储
先找段号，找页表始址，找页号，得到块号拼接页内地址

### 虚拟存储管理
程序的局部性：时间局部性和空间局部性
需要几个页面，就几次中断。
##### 先进先出（FIFO）
##### 最近最少未使用（LRU）
##### 最近未用（NUR）

## 设备管理
### I/O设备管理软件
CPU很快，外部设备很慢
分层（按顺序）
>用户级软件
>与设备无关的系统软件
>设备驱动程序
>中断处理程序
>（硬件）

#### 设备管理的相关技术 
>1通道技术
>2DMA技术
>3缓冲技术
>4Spooling技术：脱机输入输出，预先存放在缓冲区（输入井输出井）

### 磁盘调度算法
读取时间=寻道时间+旋转时间+数据传输时间
1.移臂算法（先磁道，）
>先来先服务
>最短寻道优先
>扫描算法（电梯调度）
>单向扫描调度
>

# 计算机网络
## 网络概述
### 网络互联设备

## TCP/IP
网际层有 IP协议 ARP协议（地址解析协议，ip到mac） RARP ICMP协议（网络控制信息协议，用于差错控制。ping）

![P~%M3CQU~EN77~93K6}P3W4](http://image-wangchen.oss-cn-shanghai.aliyuncs.com/img/P~%M3CQU~EN77~93K6}P3W4.png)




# 下午题
五道题

## 数据流图（20年没考）
数据流图（DFD，Data Flow Diagram）面向数据流来建模
1.数据流：由一组固定成分的数据组成，表示数据的流向
2.加工：输入数据流到输出数据流的变换，每个加工有个名字和编号
3.数据存储：什么什么表
4.外部实体：数据的发源地和数据归宿地

数据流图需要注意的地方
1.适当命名
2.画数据流不是控制流
3.**每条数据流的输入或输出是加工**
4.加工的输出和输入不应同名
5.一个加工到另一个加工可以有多个数据流
6.**父图中某加工的输入输出数据流必须与它的子图的输入输出数据流在数量和名字上相同，如果父图中一个输入输出数据流对应子图中几个输入输出数据流，而子图中组成这些数据流的数据项全体正好是父图中的这一个数据流，那么它们仍然是平衡的**
7.在自顶向下的分解过程中，若一个数据存储首次出现时只与一个加工有关，那么这个数据存储应作为这个加工的内部文件不必画出
8.保持数据守恒。**一个加工所有输出数据流中的数据必须能从该加工的输入数据流中直接获得，或者通过该加工能产生的数据。**
9.**每个加工必须有输入又有输出**
10.每个数据存储既有读又有写的数据流。但某一张子图中可能只有读或写。

数据流图总结
1.每个小标题对应一个加工。**逐字逐句仔细阅读题干说明，将每一句话与图中数据流对应**，如果有一句没有找到对应的数据流，做出标记，可能为缺失的数据流。
2.在此过程中可以对应的找到实体E和数据存储D。命名的时候一定要按照题干说明中的词语并结合实际语义来命名，不要随便乱造。
3.如果某句存疑，先做标记，最后判断。
4.根据找缺失数据流的分值来估算可能需要找几条缺失的数据流。
5.保持父图和子图平衡的话背下来。

## E-R图
### 常考的几种情况
1.两方联系：两个实体之间产生联系。说明中的句式类似AB、BA。
2.三方联系：当同一联系需要三方同时参与的时候就是三方联系。说明中的句式类似AB、BC。
3.弱实体：一个实体的存在必须以另一个实体为前提。（学生家长依赖于学生，弱实体双边矩形，依赖联系双边菱形）
4.聚合：将联系作为实体，与其他的实体产生联系。即两个实体A和B先产生联系，联系本身再与C产生联系，需要用方框把A和B之间的联系框起来（A和B联系起来再和产生联系，三方实体缺一不可。把两个实体和一个联系矩形框起来再与别的联系）
5.子实体：一个实体集可以按照某些特征区分为几个子实体,(矩形多两竖)
6.同一个实体集内的联系：同一个实体集内的两个实体之间相互存在着一定的关系。（实体和联系两条线）
>三方联系和聚合的区别：三方联系必须要三方实体同时参与，缺一不可。而聚合是有先后顺序的，两个实体先产生联系，再与第三个实体产生联系。


### 总结
1.问题1补充E-R图（概念模型设计）：将题目中的说明多读几遍，来确认参与联系的实体以及联系的类型，确认联系类型的时候一定要优先根据题干的说明来判断，如果题干可以得到的信息较少，或不足以判断，再根据题目中给出的关系模式来。
2.问题2补充关系模式中的属性（逻辑结构设计）：一般都可以从题目中的说明中找到答案，带着问题去读说明。如果一下没找到，再通读说明，根据具体语义以及E-R图去判断。
3.问题3稍难，仔细阅读，根据具体去判断

>需求分析、概念结构设计（ER图）、逻辑结构设计（关系模式）三者是相互关联的。画ER图的方法是：
>>1.依据需求分析中的文字说明来判断
>>2.以及逻辑结构设计（关系模式）来判断
>>3.依据现实中的生活经验来判断


## 关系规范化
### 常考的几个问题
1.找候选码：记住候选码的含义：候选码可以决定关系模式中的所有属性，且候选码的任何一个真子集都不能单独决定全属性。
2.是都满足某一范式，或最高可达到第几范式。
3.分解关系模式
>1.有部分函数依赖的情况：R(A,B,C,D,E,F,),F={A-(C,D,E),(A,B)-F)},有的是一个决定一个，有的是两个决定一个，即**有的候选码有2个**，有的非主属性只依赖一个，而不是依赖两个。
>2.有传递依赖的情况：R(A,B,C,D,E,F,),F={A-(B,C),B-(D,E,F)},
>3.有多值依赖的情况：R(A,B,C,D,E,F,),F={A--B,A-(C,D,E,F)},

范式：
>有非主属性对码的而部分函数依赖的，不满足2NF
>有非主属性对码的传递函数依赖的，不满足3NF
>有主属性对码的部分和函数依赖的，不满足BCNF
>有多值依赖的，例如X到到Y，X和Y必在一个关系模式，且只有X和Y，不能有其他多余属性。如果有，不满足4NF

1NF：属性不可再分
2NF：消除了部分函数依赖
3NF：消除了传递依赖
BCNF：消除了主属性对码的部分和传递函数依赖
4NF：属性间没有非平凡且非函数依赖的多值依赖


### 总结
1.找函数依赖集
2.判断候选码（唯一的，能够决定所有属性,候选码有多个的时候，一定要检查这多个中，有的是不是不需要）
3.确定主属性和非主属性，部分和传递依赖
4.确定范式
5.根据函数依赖集来分解

存在哪些问题：存在数据冗余，数据增加更新删除异常！

## 两段锁协议
（2PL）指同一事务对任何数据进行读写之前必须对该数据加锁；在释放一个封锁之后，该事务不再申请和获得任务其他封锁。
两段：事务分为两个阶段。第一阶段获得封锁，也称扩展阶段。第二阶段释放封锁，也称收缩阶段。

如果事务遵循两段锁协议，那么它们的并发调度是可串行化的。两段锁是可串行化的充分条件，而不是必要条件。即：遵循两段锁协议，一定是可串行化的，不遵循两段锁协议，可能是可串行化的。
>注意：采用两段锁协议也有可能产生死锁，这是因为每个事务都不能及时解除被封锁的数据，可能会导致多个事务都要求对方已经封锁的数据而不能继续运行。

**多个事务的并发执行是正确的，当且仅当其结果与某一次串行地执行他们的结果相同，称这种调度策略是可串行化的调度**
**可串行化是并发事务正确性的准则。即：一个给定的并发调度，当且仅当它是可串行化的才认为是正确调度**

错误类型
>丢失修改（重复修改了）
>读脏数据（一个数据撤销了）
>不可重复读（隔了一段时间再读，中间被别人修改了）


共享锁：用于只读，其他事务只能再加共享锁，不能加排他锁
排他锁：其他事务不能加任何锁









